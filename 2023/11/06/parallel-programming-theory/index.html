<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Charles">
    
    <meta name="author" content="Charles">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
        
        
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://charles2530.github.io/2023/11/06/parallel-programming-theory/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="post by Charles in 2023-11-06 12:47:19">
<meta property="og:type" content="article">
<meta property="og:title" content="parallel_programming_theory">
<meta property="og:url" content="http://charles2530.github.io/2023/11/06/parallel-programming-theory/index.html">
<meta property="og:site_name" content="Charles&#39;s Castle">
<meta property="og:description" content="post by Charles in 2023-11-06 12:47:19">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106125343731.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106125720575.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106125956111.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106130632901.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106130703603.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106130809125.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106131446504.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106131540617.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106142916070.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106142959576.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106143103093.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106145857888.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106151120523.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106152935827.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106155847244.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106160020818.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106162015225.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106162115371.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106162647977.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106162940456.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231110104343554.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231110104825177.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231110104842598.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231110104912816.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231110104937249.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231110105033487.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231110105105492.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231110105117591.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231110105256214.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231110105508978.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231117231240011.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231117231506216.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231117231515809.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231117231615962.png">
<meta property="og:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231124215425399.png">
<meta property="article:published_time" content="2023-11-06T04:47:19.000Z">
<meta property="article:modified_time" content="2023-11-24T14:41:53.941Z">
<meta property="article:author" content="Du Jinyang">
<meta property="article:tag" content="other">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://charles2530.github.io/image/parallel-programming-theory/image-20231106125343731.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="https://charles2530.github.io/image/background/favicon.png" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="https://charles2530.github.io/image/background/favicon.png">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="https://charles2530.github.io/image/background/favicon.png">
    <!--- Page Info-->
    
    <title>
        
            parallel_programming_theory -
        
        Charles&#39;s Castle
    </title>
    
<link rel="stylesheet" href="/css/style.css">


    
        <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/assets/build/styles.css">
    

    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/fonts/fonts.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/fonts/Satoshi/satoshi.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/fonts/Chillax/chillax.css">
    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
        
            
                
                    <script data-swup-reload-script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?8e0e5f382d14d87cbeadc33a36e71e86"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script>
                
    
            
    
    <script id="hexo-configurations">
    window.config = {"hostname":"charles2530.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":true,"list":["lol","Neo","God"]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":6,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":true,"title":"recommend_articles","limit":3,"mobile_limit":2,"placeholder":"https://charles2530.github.io/image/background/p3.jfif","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":"#1890ff"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":true},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"https://charles2530.github.io/image/background/background-light1.jpg","dark":"https://charles2530.github.io/image/background/background-dark1.jpg"},"title":"Charles's Castle","subtitle":{"text":["Happiness is best!","Never give up!","Everyday is a gift!"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#000000","dark":"#d1d1b6"},"text_style":{"title_size":"3.2rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"links":{"github":"https://github.com/Charles2530/","zhihu":"https://www.zhihu.com/people/yang-guang-xiao-zi-55-55","email":"charles2530@163.com"},"qrs":{"weixin":"https://charles2530.github.io/image/background/Wechat_icon.png"}}},"plugins":{"feed":{"enable":true},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null},{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":true,"version":"9.3.0"}},"version":"2.5.0","navbar":{"auto_hide":true,"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Categories":{"path":"/categories","icon":"fas fa-bookmark"},"Tags":{"path":"/tags","icon":"fas fa-tags"},"About":{"icon":"fa-regular fa-user","submenus":{"Me":"/about","Github":"https://github.com/Charles2530/","Blog":"https://charles2530.github.io","Statistics":"https://tongji.baidu.com/"}}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":"This is Charles's Castle","links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Photos":{"icon":"fa-solid fa-image","path":"/masonry/"},"Essays":{"icon":"fa-solid fa-message-lines","path":"/essay/"},"Friends":{"icon":"fa-solid fa-user-group","path":"/friends/"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/12/27 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":true};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Charles's Castle" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


  <body>
    <div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="swup-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="https://charles2530.github.io/image/background/logo.jpg">
                </a>
            
            <a class="logo-title" href="/">
                
                Charles&#39;s Castle
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/categories"  >
                                    
                                        
                                            <i class="fas fa-bookmark"></i>
                                        
                                        CATEGORIES
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/tags"  >
                                    
                                        
                                            <i class="fas fa-tags"></i>
                                        
                                        TAGS
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        ABOUT&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/about">ME
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://github.com/Charles2530/">GITHUB
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a href="https://charles2530.github.io">BLOG
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://tongji.baidu.com/">STATISTICS
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer w-full absolute top-0 left-0 bg-background-color">
        <ul class="drawer-navbar-list flex flex-col justify-start items-center">
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group " 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group " 
                        href="/categories"  >
                             
                                
                                    <i class="fas fa-bookmark"></i>
                                
                                CATEGORIES
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group " 
                        href="/tags"  >
                             
                                
                                    <i class="fas fa-tags"></i>
                                
                                TAGS
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                ABOUT&nbsp;<i class="group-hover:rotate-180 transition-transform fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="drawer-navbar-item text-base flex justify-center items-center hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                <a class="py-0.5" href="/about">ME</a>
                            </li>
                        
                            <li class="drawer-navbar-item text-base flex justify-center items-center hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                <a class="py-0.5" target="_blank" rel="noopener" href="https://github.com/Charles2530/">GITHUB</a>
                            </li>
                        
                            <li class="drawer-navbar-item text-base flex justify-center items-center hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                <a class="py-0.5" href="https://charles2530.github.io">BLOG</a>
                            </li>
                        
                            <li class="drawer-navbar-item text-base flex justify-center items-center hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                <a class="py-0.5" target="_blank" rel="noopener" href="https://tongji.baidu.com/">STATISTICS</a>
                            </li>
                        
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container">
    <div class="article-content-container">

        <div class="article-title">
            
                
                
                <img src="https://charles2530.github.io/image/background/p2.jpg" alt="parallel_programming_theory" class="max-w-none"/>
                
                <h1 class="article-title-cover">parallel_programming_theory</h1>
            
            </div>
            
                    
        
        
            <div class="article-header flex flex-row gap-2 items-center">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="https://charles2530.github.io/image/background/logo2.jpg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">Charles</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv7</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-11-06 12:47:19</span>
        <span class="mobile">2023-11-06 12:47:19</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-11-24 22:41:53</span>
            <span class="mobile">2023-11-24 22:41:53</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/Lesson/">Lesson</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/Lesson/other/">other</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/Lesson/other/parallel-programming/">parallel_programming</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/other/">other</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>11.1k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>40 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body">
            <h1 id="并行程序设计"><a class="markdownIt-Anchor" href="#并行程序设计"></a> 并行程序设计</h1>
<h2 id="并行计算基础"><a class="markdownIt-Anchor" href="#并行计算基础"></a> 并行计算基础</h2>
<h3 id="传统的并行计算"><a class="markdownIt-Anchor" href="#传统的并行计算"></a> 传统的并行计算</h3>
<ul>
<li><strong>程序在一台只有一个CPU的电脑上运行</strong></li>
<li><strong>问题被分解成离散的指令序列</strong></li>
<li><strong>指令被一条接一条的执行</strong></li>
<li><strong>在任何时间CPU上最多只有一条指令在运行</strong></li>
</ul>
<h3 id="并行计算"><a class="markdownIt-Anchor" href="#并行计算"></a> 并行计算</h3>
<ul>
<li><strong>调用多个CPU</strong></li>
<li><strong>一个问题分解成多个部分，可以被同时解决</strong></li>
<li><strong>每一部分被细分成一系列指令</strong></li>
<li><strong>每一部分的指令可以在不同的CPU上同时执行</strong></li>
</ul>
<h3 id="并发vs并行"><a class="markdownIt-Anchor" href="#并发vs并行"></a> 并发vs并行</h3>
<ul>
<li><strong>并发</strong>:<strong>一个逻辑流的执行在时间上与另一个流重叠，在某时间段内可能是交替执行，也可能是同时执行。</strong></li>
<li><strong>并行:两个逻辑流在任意时刻同时执行</strong></li>
</ul>
<blockquote>
<p><strong>从并行计算的角度，并行是并发的真子集。注意：某些情况下，并发特指交替执行。</strong></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106125343731.png"
                      alt="image-20231106125343731" 
                ></p>
<h3 id="并行vs分布式"><a class="markdownIt-Anchor" href="#并行vs分布式"></a> 并行vs分布式</h3>
<blockquote>
<p><strong>并行与分布式的涵义不同，但没有非常明显的界限</strong></p>
</blockquote>
<ul>
<li><strong>并行计算中，线程（或者进程）间通信往往通过共享内存，处理器间的交互一般很频繁。</strong></li>
<li><strong>分布式计算，进程间的通信依赖网络，例如，利用多台机器或者处于不同地理位置的机器进行计算。</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106125720575.png"
                      alt="image-20231106125720575" 
                ></p>
<h3 id="并行计算的应用"><a class="markdownIt-Anchor" href="#并行计算的应用"></a> 并行计算的应用</h3>
<ul>
<li>历史上<strong>并行计算被认为是“高端计算”，并用于为复杂的科学计算和真实世界的工程问题建模。</strong></li>
<li>今天<strong>商业应用是推动并行计算机发展的更大的推动力，这些应用需要用复杂的方法处理大量数据。</strong></li>
</ul>
<h3 id="并行的层次"><a class="markdownIt-Anchor" href="#并行的层次"></a> 并行的层次</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106125956111.png"
                      alt="image-20231106125956111" 
                ></p>
<h3 id="并行计算机分类"><a class="markdownIt-Anchor" href="#并行计算机分类"></a> 并行计算机分类</h3>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">单指令<br>(Single Instruction)</th>
<th style="text-align:center">多指令<br>(Multiple Instruction)</th>
</tr>
</thead>
<tbody>
<tr>
<td>单数据<br/>Single Data</td>
<td style="text-align:center">SISD</td>
<td style="text-align:center">MISD</td>
</tr>
<tr>
<td>多数据<br/>Multiple Data</td>
<td style="text-align:center">SIMD</td>
<td style="text-align:center">MIMD</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong>SISD</strong></p>
<ul>
<li><strong>串行计算机</strong></li>
<li><strong>一个时钟周期，只有一条指令被执行，只有一个数据流作为输入。</strong></li>
</ul>
</li>
<li>
<p><strong>SIMD</strong></p>
<ul>
<li><strong>并行计算机</strong></li>
<li><strong>一个时钟周期，所有执行单元执行相同的指令，每个执行单元处理不同的数据元素。比较适合向量计算。</strong></li>
</ul>
</li>
<li>
<p><strong>MISD</strong></p>
<ul>
<li><strong>并行计算机</strong></li>
<li><strong>一个时钟周期，单个数据流同时被多个执行单元执行。</strong></li>
</ul>
</li>
<li>
<p><strong>MIMD</strong></p>
<ul>
<li><strong>并行计算机</strong></li>
<li><strong>多个处理单元都是根据不同的控制流程执行不同的操作，处理不同的数据。目前多数计算机属于此类。</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>根据访问内存的方式，可将并行计算机分为共享内存、分布式内存、分布式共享内存：</strong></p>
</blockquote>
<h4 id="共享内存shared-memory"><a class="markdownIt-Anchor" href="#共享内存shared-memory"></a> 共享内存(Shared Memory)</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106130632901.png"
                      alt="image-20231106130632901" 
                ></p>
<h4 id="分布式内存distributed-memory"><a class="markdownIt-Anchor" href="#分布式内存distributed-memory"></a> 分布式内存(Distributed Memory)</h4>
<blockquote>
<p><strong>每个处理器都有自己独享的物理内存，只能通过网络与其它处理器交换数据。</strong></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106130703603.png"
                      alt="image-20231106130703603" 
                ></p>
<h4 id="分布式共享内存distributed-shared-memory"><a class="markdownIt-Anchor" href="#分布式共享内存distributed-shared-memory"></a> 分布式共享内存(Distributed-Shared Memory)</h4>
<blockquote>
<p><strong>共享内存并行计算机通过网络互连，目前高性能计算、超级计算机多属于此类</strong>。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106130809125.png"
                      alt="image-20231106130809125" 
                ></p>
<h2 id="多进程程序设计"><a class="markdownIt-Anchor" href="#多进程程序设计"></a> 多进程程序设计</h2>
<h3 id="进程的概念和特点"><a class="markdownIt-Anchor" href="#进程的概念和特点"></a> 进程的概念和特点</h3>
<h4 id="进程相关的概念"><a class="markdownIt-Anchor" href="#进程相关的概念"></a> <strong>进程相关的概念</strong></h4>
<ul>
<li>进程：执行中的程序的实例。系统中的每一个进程都运行在<strong>上下文</strong>(context)中。</li>
<li>上下文：由程序正确运行所需要的<strong>状态</strong>组成，包括：
<ul>
<li><strong>存放在内存中的代码和数据</strong></li>
<li><strong>堆栈、寄存器内容、程序计数器、环境变量、文件描述符</strong></li>
</ul>
</li>
<li>系统调用：由操作系统提供的应用程序编程接口(API)</li>
<li>上下文切换：就是从一个可执行进程切换到另一个可执行进程。引发上下文切换的原因：
<ul>
<li><strong>I/O request:</strong> <strong>Process is placed on I/O queue for a device</strong></li>
<li><strong>Spawn and wait:</strong> <strong>Sometimes when a process creates a new</strong> <strong>process, it must wait until the child completes</strong></li>
<li><strong>Time slice expiration</strong></li>
<li><strong>Sleep request</strong></li>
</ul>
</li>
</ul>
<h4 id="进程与线程区别"><a class="markdownIt-Anchor" href="#进程与线程区别"></a> <strong>进程与线程区别</strong></h4>
<ul>
<li><strong>一个进程可以包括多个线程</strong></li>
<li><strong>线程间共享地址空间，因此，一个线程修改一个变量（全局或静态），其它线程都能获知</strong></li>
<li><strong>线程间通信直接通过共享变量，而进程间通信则需要通过管道、消息队列等</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106131446504.png"
                      alt="image-20231106131446504" 
                ></p>
<h4 id="进程间通信模型"><a class="markdownIt-Anchor" href="#进程间通信模型"></a> <strong>进程间通信模型</strong></h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106131540617.png"
                      alt="image-20231106131540617" 
                ></p>
<h3 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h3>
<h4 id="进程id"><a class="markdownIt-Anchor" href="#进程id"></a> 进程ID</h4>
<p><strong>每一个进程都有唯一的非零正数ID(PID)</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="type">void</span>)</span></span>;<span class="comment">//调用者进程ID</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="type">void</span>)</span></span>;<span class="comment">//调用者父进程进程ID</span></span><br></pre></td></tr></table></figure></div>
<h4 id="进程创建"><a class="markdownIt-Anchor" href="#进程创建"></a> 进程创建</h4>
<p><strong>&quot;fork&quot;:把当前进程复制出一个新的进程,当前的进程就是新进程的父进程，新进程称为子进程。</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>
<p><strong>调用一次，返回两次</strong></p>
<ul>
<li><strong>返回到父进程；</strong></li>
<li><strong>返回到新创建的子进程；</strong></li>
</ul>
</li>
<li>
<p><strong>并发执行</strong></p>
<ul>
<li><strong>宏观上，父子进程并发执行</strong></li>
<li><strong>微观上（多核系统），可能是交替执行或者并行执行</strong></li>
</ul>
</li>
<li>
<p><strong>相同但是独立的地址空间</strong></p>
<ul>
<li><strong>复制：相同的用户栈、相同的本地变量、相同的堆、相同的全局变量</strong></li>
<li><strong>独立：父子进程都有独立的私有地址空间，对变量的任何更改不会影响另外一个进程对应的变量</strong></li>
</ul>
</li>
<li>
<p><strong>文件共享</strong></p>
<ul>
<li><strong>父进程打开的文件描述符，子进程可以继续使用</strong></li>
</ul>
</li>
</ul>
<h4 id="进程终止"><a class="markdownIt-Anchor" href="#进程终止"></a> 进程终止</h4>
<ul>
<li>进程终止的三种方式:
<ul>
<li>收到一个信号，信号的默认行为是终止运行</li>
<li>从主程序返回</li>
<li>调用exit函数</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exit</span><span class="params">(<span class="type">int</span> status)</span></span>;</span><br><span class="line"><span class="comment">//调用exit函数，主动退出运行</span></span><br></pre></td></tr></table></figure></div>
<h4 id="子进程回收"><a class="markdownIt-Anchor" href="#子进程回收"></a> 子进程回收</h4>
<ul>
<li><strong>僵尸进程</strong>:<strong>子进程先于父进程终止运行，但是尚未被父进程回收，内核并未清除该进程，保持在一种已终止状态，该进程称为&quot;僵尸进程&quot;（僵死进程）</strong></li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait</span><span class="params">(<span class="type">int</span> * status)</span></span>;</span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>wait:父进程阻塞，直到一个子进程运行结束。</strong></li>
<li><strong>waitpid:比wait更加灵活，可以是非阻塞的。</strong>
<ul>
<li><strong>参数:pid_t pid</strong>
<ul>
<li><strong>pid &gt; 0: 等待进程id为pid的子进程。</strong></li>
<li><strong>pid == 0: 等待与自己同组的任意子进程。</strong></li>
<li><strong>pid == -1: 等待任意一个子进程</strong></li>
<li><strong>pid &lt; -1: 等待进程组号为-pid的任意子进程。</strong></li>
</ul>
</li>
<li><strong>参数:int options</strong>
<ul>
<li><strong>0：阻塞，即挂起调用进程;</strong></li>
<li><strong>WNOHANG：非阻塞，即如果指定的子进程都还没有终止运行，立即返回0；否则返回，终止运行进程ID;</strong></li>
<li><strong>WUNTRACED：如果子进程挂起（暂停），则立即返回；默认只返回终止运行的进程；</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>wait(&amp;stat)等价于waitpid(-1, &amp;stat, 0)</strong></p>
</blockquote>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//退出状态解析</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait_exit</span><span class="params">(<span class="type">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))&#123;</span><br><span class="line">		<span class="comment">//正常退出</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status))&#123;</span><br><span class="line">		<span class="comment">//非正常退出</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSTOPPED</span>(status))&#123;</span><br><span class="line">		<span class="comment">//暂停(挂起)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="执行一个新程序"><a class="markdownIt-Anchor" href="#执行一个新程序"></a> 执行一个新程序</h4>
<p><strong>启动一个新的程序，新的地址空间完全覆盖当前进程的地址空间</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *argv[],<span class="type">const</span> <span class="type">char</span> *envp[])</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>参数
<ul>
<li><strong>path：执行文件</strong></li>
<li><strong>argv：参数表</strong></li>
<li><strong>envp：环境变量表，一般直接用environ就行</strong></li>
</ul>
</li>
</ul>
<h3 id="信号signal"><a class="markdownIt-Anchor" href="#信号signal"></a> 信号(signal)</h3>
<ul>
<li>信号：也称作<strong>软中断</strong>，是Linux操作系统用来<strong>通知进程</strong>发生了某种<strong>异步事件</strong>的一种手段。</li>
<li><strong>常见信号</strong>
<ul>
<li><strong>SIGINT</strong>:<strong>前台程序执行过程中按下Ctrl-c就会向它发出SIGINT信号，默认终止进程</strong></li>
<li><strong>SIGKILL</strong>:<strong>立即中止进程，不能被捕获或忽略</strong></li>
<li><strong>SIGTERM</strong>:<strong>kill命令默认的中止程序信号</strong></li>
<li><strong>SIGALRM</strong>:<strong>定时器到期，可用alarm函数来设置定时器。默认动作终止进程</strong></li>
<li><strong>SIGCHLD</strong>:<strong>子进程终止或停止，默认动作为忽略（waitpid）</strong></li>
<li><strong>SIGSEGV</strong>:<strong>无效的内存引用</strong></li>
</ul>
</li>
</ul>
<h4 id="发送信号"><a class="markdownIt-Anchor" href="#发送信号"></a> 发送信号</h4>
<ul>
<li><strong>内核通过更新目的进程上下文的某个状态（pending位向量,blocked位向量），来实现信号的发送。</strong></li>
<li><strong>信号发送起因</strong>
<ul>
<li><strong>内核检测到一个系统事件：除零、子进程终止、非法内存引用</strong></li>
<li><strong>一个进程调用了kill函数：显式要求内核向目的进程发送信号，目的进程可以是调用进程自身</strong></li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kill 函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(pid t pid, <span class="type">int</span> sig)</span></span>;</span><br><span class="line"><span class="comment">//向其它进程（包括自己）发送信号向其它进程（包括自己）发送信号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//alarm 函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span></span>;</span><br><span class="line"><span class="comment">//给自己发送时钟信号(SIGALRM)</span></span><br></pre></td></tr></table></figure></div>
<h4 id="接收信号"><a class="markdownIt-Anchor" href="#接收信号"></a> 接收信号</h4>
<ul>
<li><strong>当进程接收到一个信号（可能是自己发出，也可能是别的有权限的进程发出），它可以采取的动作可以是下面任意一种：</strong></li>
<li><strong>信号处理</strong>
<ul>
<li><strong>忽略信号：SIGSTOP与SIGKILL除外</strong></li>
<li><strong>捕获信号：通过系统调用，自定义接收到信号后采取的行动。SIGSTOP与SIGKILL除外</strong></li>
<li><strong>执行信号的默认动作</strong></li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="type">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span></span></span></span><br><span class="line"><span class="params"><span class="function">sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure></div>
<h4 id="同时接收多个信号"><a class="markdownIt-Anchor" href="#同时接收多个信号"></a> <strong>同时接收多个信号</strong></h4>
<ul>
<li><strong>情况1：如果SIGUSR1的信号处理函数正在执行，第二个SIGUSR1到达</strong>
<ul>
<li><strong>SIGUSR1存入pending位向量，针对该信号的处理函数随后执行</strong></li>
</ul>
</li>
<li><strong>情况2：pending位向量内已经存在一个SIGUSR1，一个新的SIGUSR1到达？</strong>
<ul>
<li><strong>新的SIGUSR1信号被丢弃</strong></li>
</ul>
</li>
</ul>
<h4 id="信号阻塞"><a class="markdownIt-Anchor" href="#信号阻塞"></a> 信号阻塞</h4>
<p><strong>信号阻塞：目的进程接收但是不处理该信号，直到取消阻塞。</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">sigset_t</span> </span></span></span><br><span class="line"><span class="params"><span class="function">*oldset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span></span>;</span><br></pre></td></tr></table></figure></div>
<h3 id="进程间通信"><a class="markdownIt-Anchor" href="#进程间通信"></a> 进程间通信</h3>
<ul>
<li>进程间通信（IPC）：多个进程间<strong>协作或沟通</strong>的桥梁</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106142916070.png"
                      alt="image-20231106142916070" 
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106142959576.png"
                      alt="image-20231106142959576" 
                ></p>
<h4 id="消息队列"><a class="markdownIt-Anchor" href="#消息队列"></a> 消息队列</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106143103093.png"
                      alt="image-20231106143103093" 
                ></p>
<h5 id="特殊情况"><a class="markdownIt-Anchor" href="#特殊情况"></a> 特殊情况</h5>
<ul>
<li>队列满(发送进程)
<ul>
<li>阻塞</li>
<li>失败返回(非阻塞)</li>
</ul>
</li>
<li>队列空(接收进程)
<ul>
<li>阻塞</li>
<li>失败返回(非阻塞)</li>
</ul>
</li>
</ul>
<h5 id="消息队列操作"><a class="markdownIt-Anchor" href="#消息队列操作"></a> 消息队列操作</h5>
<ul>
<li>打开消息队列</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">//打开已经存在的队列</span></span><br><span class="line"><span class="function"><span class="type">mqd_t</span> <span class="title">mq_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">mqd_t</span> <span class="title">mq_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode, <span class="keyword">struct</span> mq_attr *attr)</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>队列属性</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="comment">//获取队列属性</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_getattr</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="keyword">struct</span> mq_attr *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_setattr</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="keyword">struct</span> mq_attr *newattr,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">struct</span> mq_attr *oldattr)</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>发送消息</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_send</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="type">char</span> *msg_ptr, <span class="type">size_t</span> msg_len, <span class="type">unsigned</span> <span class="type">int</span> msg_prio)</span></span>;</span><br></pre></td></tr></table></figure></div>
<p><strong>msg_ptr: 发送的消息缓冲区（传入）</strong></p>
<p><strong>msg_len: 消息实际长度（传入）</strong></p>
<p><strong>msg_prio: 消息优先级（传入）</strong></p>
<ul>
<li>接收消息</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">mq_receive</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">char</span> *msg_ptr, <span class="type">size_t</span> msg_len, <span class="type">unsigned</span> <span class="type">int</span> *msg_prio)</span></span>;</span><br></pre></td></tr></table></figure></div>
<p><strong>msg_ptr: 接收到的消息缓冲区（传出）</strong></p>
<p><strong>msg_len: 消息缓冲区大小（传入）</strong></p>
<p><strong>msg_prio: 接收消息的优先级（传出）</strong></p>
<ul>
<li>关闭队列</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_close</span><span class="params">(<span class="type">mqd_t</span> mqdes)</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>删除队列</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure></div>
<h4 id="信号量named-semaphores"><a class="markdownIt-Anchor" href="#信号量named-semaphores"></a> <strong>信号量（named semaphores）</strong></h4>
<ul>
<li><strong>信号量(semaphore)：用来对共享资源进行并发访问控制。</strong></li>
</ul>
<h5 id="信号量相关操作"><a class="markdownIt-Anchor" href="#信号量相关操作"></a> 信号量相关操作</h5>
<ul>
<li>打开信号量</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">sem_t</span> *<span class="title">sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">sem_t</span> *<span class="title">sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>关闭信号量</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_close</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>删除信号量</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>test and decrement</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><strong>sem_wait：</strong></p>
<ul>
<li><strong>(1) 若信号量的值等于0，阻塞，直到值大于0；</strong></li>
<li><strong>(2) 若信号量的值大于0，值减1；</strong></li>
</ul>
<p><strong>sem_trywait：</strong></p>
<ul>
<li><strong>不会阻塞，返回-1，errno == EAGAIN；</strong></li>
</ul>
</blockquote>
<ul>
<li>increment</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span>*valp)</span></span>;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><strong>sem_post：</strong></p>
<ul>
<li><strong>(1) 信号量的值加1，唤醒等待进程；</strong></li>
<li><strong>(2) 若信号量的值大于0，值减1；</strong></li>
</ul>
</blockquote>
<ul>
<li>取得等待的进程数目</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span>*valp)</span></span>;</span><br></pre></td></tr></table></figure></div>
<h2 id="多线程程序设计"><a class="markdownIt-Anchor" href="#多线程程序设计"></a> 多线程程序设计</h2>
<h3 id="线程基础"><a class="markdownIt-Anchor" href="#线程基础"></a> 线程基础</h3>
<h4 id="线程定义"><a class="markdownIt-Anchor" href="#线程定义"></a> 线程定义</h4>
<ul>
<li><strong>线程可认为是进程内部的执行流，一个进程内可包括多个线程，一个显著特点是线程间共享地址空间。</strong></li>
<li><strong>线程：进程内独立的执行流</strong>
<ul>
<li><strong>进程开始执行时只有一个线程，称为主线程（main thread）</strong></li>
<li><strong>独立执行：线程间互相独立，与进程类似</strong></li>
<li><strong>共享地址空间：共享堆(指针)、数据段(静态变量、全局变量)</strong> <strong>、代码段</strong></li>
<li><strong>独立的栈：临时变量可间接共享</strong></li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106145857888.png"
                      alt="image-20231106145857888" 
                ></p>
<h4 id="线程优势"><a class="markdownIt-Anchor" href="#线程优势"></a> <strong>线程优势</strong></h4>
<ul>
<li><strong>提高性能（相比进程）</strong>
<ul>
<li><strong>线程创建快：与进程共享资源，因此，创建线程不需要复制整个地址空间</strong></li>
<li><strong>上下文切换快：从同一个进程内的一个线程切换到另一个线程时需要载入的信息比进程少</strong></li>
</ul>
</li>
<li><strong>便捷的数据共享（相比进程）</strong>
<ul>
<li><strong>不必通过内核就可以共享和传递数据。线程间通信比进程间通信高效、方便</strong></li>
</ul>
</li>
</ul>
<h4 id="使用线程"><a class="markdownIt-Anchor" href="#使用线程"></a> <strong>使用线程</strong></h4>
<ul>
<li>
<p><strong>工作可以被多个任务同时执行，或者数据可以同时被多个任务操作</strong></p>
</li>
<li>
<p><strong>阻塞与潜在的长时间I/O等待</strong></p>
</li>
<li>
<p><strong>在某些地方使用很多CPU循环而其他地方没有</strong></p>
</li>
<li>
<p><strong>对异步事件必须响应</strong></p>
</li>
<li>
<p><strong>一些工作比其他的重要（优先级中断）</strong></p>
</li>
<li>
<p>线程风险</p>
<ul>
<li><strong>增加程序复杂性</strong></li>
<li><strong>难于调试</strong>(<strong>竞态条件、死锁……</strong>)</li>
</ul>
</li>
</ul>
<h3 id="线程的基本操作"><a class="markdownIt-Anchor" href="#线程的基本操作"></a> 线程的基本操作</h3>
<h4 id="线程创建"><a class="markdownIt-Anchor" href="#线程创建"></a> 线程创建</h4>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> * (start_routine)(<span class="type">void</span> *);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> * tid, <span class="type">pthread_attr_t</span> * attr, start_routine* f, <span class="type">void</span> * arg)</span></span>;</span><br></pre></td></tr></table></figure></div>
<p><strong>pthread_t* tid：新创建线程的ID</strong> <strong>(传出参数)</strong></p>
<p><strong>pthread_attr_t* attr：设置线程属性，可以是NULL(传入参数)</strong></p>
<p><strong>start_routine* f：在新线程中运行的函数地址(传入参数)</strong></p>
<p><strong>void* arg：函数f的参数，如果要传多个参数，使用结构体指针</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106151120523.png"
                      alt="image-20231106151120523" 
                ></p>
<h4 id="线程标识"><a class="markdownIt-Anchor" href="#线程标识"></a> 线程标识</h4>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;ht, <span class="literal">NULL</span>, &amp;func, str);</span><br><span class="line"><span class="comment">// 线程ID 线程属性 入口函数 入口函数参数</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>获取当前线程的ID，在线程内调用该函数</strong></li>
<li><strong>pthread_t有可能是无符号整型(linux)、结构体、指针，为了可移植性，尽量不要打印。</strong></li>
</ul>
<h4 id="线程回收"><a class="markdownIt-Anchor" href="#线程回收"></a> <strong>线程回收</strong></h4>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待(回收)线程</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> tid, <span class="type">void</span> **thread_return)</span></span>;</span><br></pre></td></tr></table></figure></div>
<p><strong>等待tid线程终止运行，如果该线程已经终止，立即返回；否则，阻塞直到该线程终止</strong></p>
<p><strong>与wait不同，pthread_join只能等待一个指定的线程终止，不能等待任意一个线程终止</strong></p>
<ul>
<li><strong>pthread_t tid：要等待的线程ID</strong> <strong>(传入参数)</strong></li>
<li><em><em>void*</em> thread_return：线程函数返回的 (void *)指针赋给thread_return所指的地址，可以是NULL（传出参数）</em>*</li>
</ul>
<h4 id="线程终止"><a class="markdownIt-Anchor" href="#线程终止"></a> <strong>线程终止</strong></h4>
<p>线程终止的三种方式：</p>
<ul>
<li>从线程函数返回；</li>
<li>被同进程内的其它线程取消(pthread_cancel)；</li>
<li>调用pthread_exit函数；</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span> *rval_ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> tid)</span></span>;</span><br><span class="line"><span class="comment">//线程取消时执行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="type">void</span> (*rtn)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="type">int</span> execute)</span></span>;</span><br></pre></td></tr></table></figure></div>
<p><strong>pthread_cancel并不会立即终止另一个线程，只是发送了请求，另一个线程在到达cancellation point（系统调用）的时候才终止</strong></p>
<h4 id="线程分离"><a class="markdownIt-Anchor" href="#线程分离"></a> 线程分离</h4>
<ul>
<li>线程分离:在任何时间点上，线程是 可结合的(joinable) 或者是分离的(detached)。可结合的线程如果没有被回收，存储资源（栈等）不会被释放；分离的线程不能被回收或者杀死，线程终止时，存储资源由系统自动释放。</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//分离可结合线程tid</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span></span>;</span><br></pre></td></tr></table></figure></div>
<h3 id="多线程的共享变量"><a class="markdownIt-Anchor" href="#多线程的共享变量"></a> <strong>多线程的共享变量</strong></h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106152935827.png"
                      alt="image-20231106152935827" 
                ></p>
<h3 id="线程同步"><a class="markdownIt-Anchor" href="#线程同步"></a> <strong>线程同步</strong></h3>
<blockquote>
<p>利用共享变量进行线程间通信，但容易引起&quot;同步错误&quot;</p>
</blockquote>
<h4 id="互斥mutex"><a class="markdownIt-Anchor" href="#互斥mutex"></a> 互斥(Mutex)</h4>
<p><strong>互斥:可以看作一把锁，保护共享资源同一时刻只能被一个线程访问。</strong></p>
<ul>
<li>互斥初始化和销毁</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>加锁和解锁</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//如果mutex已经被锁，调用线程阻塞，直到mutex被解锁。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//如果mutex已经被锁，不阻塞，返回EBUSY 。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//解锁</span></span><br></pre></td></tr></table></figure></div>
<h4 id="信号量semaphore"><a class="markdownIt-Anchor" href="#信号量semaphore"></a> <strong>信号量(semaphore)</strong></h4>
<ul>
<li>信号量初始化和销毁</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="number">0</span>, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>P和V</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">/*P操作*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span> <span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">//如果信号量的值大于0,那么进行减一的操作,函数立即返回. </span></span><br><span class="line"><span class="comment">//如果信号量当前等于0,那么调用就会阻塞，直到信号量大于0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">//如果信号量的值大于0,那么进行减一的操作,函数立即返回. </span></span><br><span class="line"><span class="comment">//如果信号量当前等于0,函数立即返回，errno等于EAGAIN</span></span><br><span class="line"><span class="comment">/*V操作*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">//信号量的值增加1，阻塞在这个信号量上的一个线程将会被唤醒</span></span><br></pre></td></tr></table></figure></div>
<h4 id="条件变量"><a class="markdownIt-Anchor" href="#条件变量"></a> 条件变量</h4>
<ul>
<li>
<p>条件变量:<strong>是一种等待某事件发生的一种同步机制。即，线程挂起，直到共享数据上的某些条件得到满足。</strong></p>
</li>
<li>
<p>注意要点:</p>
<ul>
<li><strong>条件变量是用来等待而不是用来上锁。它是通过一种能够挂起当前正在执行的进程或者放弃当前进程，直到在共享数据上的一些条件得到满足。</strong></li>
<li><strong>条件变量的操作过程是：首先通知条件变量，然后等待，同时挂起当前进程直到有另外一个进程通知该条件变量为止。</strong></li>
</ul>
</li>
</ul>
<h5 id="条件变量初始化和销毁"><a class="markdownIt-Anchor" href="#条件变量初始化和销毁"></a> 条件变量初始化和销毁</h5>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_condattr_t</span> *cond_attr)</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure></div>
<h5 id="等待条件成立"><a class="markdownIt-Anchor" href="#等待条件成立"></a> 等待条件成立</h5>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *abstime)</span></span>;</span><br></pre></td></tr></table></figure></div>
<h5 id="唤醒等待线程"><a class="markdownIt-Anchor" href="#唤醒等待线程"></a> 唤醒等待线程</h5>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure></div>
<h5 id="解锁线程"><a class="markdownIt-Anchor" href="#解锁线程"></a> 解锁线程</h5>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">condition_is_false=<span class="literal">false</span>;</span><br><span class="line"><span class="built_in">pthread_cond_signal</span>(&amp;cond)</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex)</span><br></pre></td></tr></table></figure></div>
<h3 id="多线程信号处理"><a class="markdownIt-Anchor" href="#多线程信号处理"></a> <strong>多线程信号处理</strong></h3>
<ul>
<li><strong>同步信号(synchronous signals)：<strong>进程(线程)的某个操作产生的信号,例如</strong>SEGILL、SIGSEGV、SIGFPE等</strong>。</li>
<li>**异步信号(asynchronous signals)：**类似用户击键这样的进程外部事件产生的信号叫做异步信号，例如kill命令、ctrl+c产生的信号。</li>
</ul>
<h4 id="线程信号处理函数"><a class="markdownIt-Anchor" href="#线程信号处理函数"></a> 线程信号处理函数</h4>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_sigmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">sigset_t</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> sig)</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigwait</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">int</span> *sig)</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>异步信号由哪一个线程接收?</strong>
<ul>
<li><strong>如果所有线程都未阻塞该信号，则接收线程不确定，可能是任意线程；</strong></li>
<li><strong>如果只有一个线程未阻塞该信号，则信号将送达该线程。</strong></li>
</ul>
</li>
</ul>
<h3 id="并发常见问题"><a class="markdownIt-Anchor" href="#并发常见问题"></a> <strong>并发常见问题</strong></h3>
<h4 id="线程安全"><a class="markdownIt-Anchor" href="#线程安全"></a> <strong>线程安全</strong></h4>
<ul>
<li>线程安全:<strong>一段代码(函数）被称为线程安全的，当且仅当被多个线程反复调用时，一直产生正确的结果。</strong></li>
<li>线程不安全分类:
<ul>
<li>共享资源(变量)未做保护
<ul>
<li>不保护共享变量</li>
<li>意外共享</li>
<li>共享资源操作未保护</li>
</ul>
</li>
<li>返回指向静态变量的指针的函数</li>
<li>调用线程不安全的函数</li>
</ul>
</li>
</ul>
<h4 id="可重入函数reentrant-function"><a class="markdownIt-Anchor" href="#可重入函数reentrant-function"></a> <strong>可重入函数(reentrant function)</strong></h4>
<ul>
<li><strong>显示可重入:所有的函数参数都是传值传递的，并且所有的数据引用都是本地的自动栈变量</strong></li>
</ul>
<h4 id="竞争"><a class="markdownIt-Anchor" href="#竞争"></a> <strong>竞争</strong></h4>
<ul>
<li>竞争:<strong>当一个程序的正确性依赖于一个线程在另一个线程到达y点之前，到达它的控制流中的x点时，就会发生竞争。</strong></li>
</ul>
<h4 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> <strong>死锁</strong></h4>
<ul>
<li>死锁:<strong>信号量引入死锁。一组线程被阻塞了，等待一个永远也不会为真的条件。</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106155847244.png"
                      alt="image-20231106155847244" 
                ></p>
<h4 id="假共享"><a class="markdownIt-Anchor" href="#假共享"></a> <strong>假共享</strong></h4>
<ul>
<li>假共享:<strong>分别被两个线程使用的变量，由于存储位置靠得太近，有可能被放到一个cache line（通常64字节）内，此时会引起假共享，严重影响性能。</strong></li>
</ul>
<h4 id="线程个数限制"><a class="markdownIt-Anchor" href="#线程个数限制"></a> <strong>线程个数限制</strong></h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106160020818.png"
                      alt="image-20231106160020818" 
                ></p>
<h2 id="mpi并行程序设计"><a class="markdownIt-Anchor" href="#mpi并行程序设计"></a> MPI并行程序设计</h2>
<blockquote>
<p>这部分可以参考<a href="https://charles2530.github.io/categories/Applications/MPI/">Category: MPI - Charles’s Castle (charles2530.github.io)</a></p>
</blockquote>
<h3 id="认识mpi"><a class="markdownIt-Anchor" href="#认识mpi"></a> 认识MPI</h3>
<h4 id="什么是mpi"><a class="markdownIt-Anchor" href="#什么是mpi"></a> <strong>什么是MPI</strong></h4>
<ul>
<li>MPI:<strong>Message Passing Interface，消息传递接口。是很多公司和组织共同制定的标准，用于进程间通信。是集群系统最流行的编程模型。有名的免费实现有：MPICH、</strong> <strong>LAM/MPI</strong> <strong>。</strong></li>
</ul>
<h4 id="消息通信模型"><a class="markdownIt-Anchor" href="#消息通信模型"></a> <strong>消息通信模型</strong></h4>
<ul>
<li><strong>消息传递特点：</strong>
<ul>
<li><strong>通过网络传递数据（消息）；</strong></li>
<li><strong>send和receive必须配对使用；</strong></li>
<li><strong>send和receive分阻塞和非阻塞；</strong></li>
</ul>
</li>
</ul>
<h3 id="mpi编程基础"><a class="markdownIt-Anchor" href="#mpi编程基础"></a> <strong>MPI编程基础</strong></h3>
<h4 id="mpi初始化"><a class="markdownIt-Anchor" href="#mpi初始化"></a> MPI初始化</h4>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “mpi.h”</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Init</span><span class="params">(<span class="type">int</span> *argc, <span class="type">char</span> ** argv)</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>MPI_INIT必须在其它MPI函数之前调用，它完成MPI程序所有的初始化工作</strong></li>
<li><strong>main函数必须带参数运行,否则出错</strong></li>
</ul>
<h4 id="mpi结束"><a class="markdownIt-Anchor" href="#mpi结束"></a> MPI结束</h4>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “mpi.h”</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Finalize</span><span class="params">( )</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>MPI_FINALIZE是MPI程序的最后一个调用</strong></li>
<li><strong>标志并行代码的结束,结束除主进程外其它进程</strong></li>
</ul>
<h4 id="当前进程id"><a class="markdownIt-Anchor" href="#当前进程id"></a> <strong>当前进程ID</strong></h4>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “mpi.h”</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Comm_rank</span><span class="params">(MPI_Comm comm, <span class="type">int</span> *rank)</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>返回调用进程在给定的通信域中的进程ID（整型，从0开始编号）</strong></li>
<li><strong>根据ID，不同的进程就可以将自身和其它的进程区别开来，实现各进程的并行和协作</strong></li>
</ul>
<h4 id="通信域内的进程数"><a class="markdownIt-Anchor" href="#通信域内的进程数"></a> <strong>通信域内的进程数</strong></h4>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “mpi.h”</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Comm_size</span><span class="params">(MPI_Comm comm, <span class="type">int</span> *size)</span></span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>返回给定的通信域中所包括的进程的个数</strong></li>
</ul>
<blockquote>
<p><strong>通信域也可翻译为通信子，在MPI中用来定义进程通信的范围。<strong>MPI_COMM_WORLD是MPI预定义的</strong>全局通信域</strong></p>
</blockquote>
<ul>
<li><strong>一个MPI程序可以有多个通信域，每一个进程组只能与组内的成员通信进程组：进程的集合，可根据进程组创建通信域</strong></li>
</ul>
<h4 id="发送消息"><a class="markdownIt-Anchor" href="#发送消息"></a> <strong>发送消息</strong></h4>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “mpi.h”</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Send</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> * buf, <span class="comment">//发送缓冲区的地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> count, <span class="comment">//发送数据元素的个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Datatype type, <span class="comment">//发送数据元素的类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> dest, <span class="comment">//目标进程的ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> tag, <span class="comment">//消息标签</span></span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Comm comm <span class="comment">//通信域</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>将消息发送至另外一个进程</strong></li>
<li><strong>阻塞发送：直到消息被发送出去，该函数才返回</strong></li>
</ul>
<h4 id="接收消息"><a class="markdownIt-Anchor" href="#接收消息"></a> <strong>接收消息</strong></h4>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “mpi.h”</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Recv</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> * buf, <span class="comment">//接收缓冲区的起始地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> count, <span class="comment">//接收数据元素的个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Datatype type, <span class="comment">//接收数据元素的类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> source, <span class="comment">//发送进程的ID或MPI_ANY_SOURCE</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> tag, <span class="comment">//消息标签</span></span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Comm comm, <span class="comment">//通信域</span></span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Status *status <span class="comment">//接收操作的状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>从其它进程接收消息，如果从其它任意进程接收消息，source参数使MPI_ANY_SOURCE</strong></li>
<li><strong>阻塞接收：直到接收到消息后，该函数才返回</strong></li>
</ul>
<h4 id="死锁的产生"><a class="markdownIt-Anchor" href="#死锁的产生"></a> <strong>死锁的产生</strong></h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106162015225.png"
                      alt="image-20231106162015225" 
                ></p>
<ul>
<li><strong>确保一次发送数据量小于环境所能提供缓冲区容量</strong></li>
<li><strong>利用MPI环境消息的顺序性约束，调整语句的执行顺序</strong></li>
<li><strong>使用缓冲发送模式（MPI_Buffer_attach(); MPI_Buffer_detach()…）</strong></li>
<li><strong>使用非阻塞通信(MPI_Isend()…)</strong></li>
<li><strong>利用组合发送接收(MPI_Sendrecv()…)</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106162115371.png"
                      alt="image-20231106162115371" 
                ></p>
<h5 id="各种模式对缓冲区使用的方式"><a class="markdownIt-Anchor" href="#各种模式对缓冲区使用的方式"></a> <strong>各种模式对缓冲区使用的方式</strong></h5>
<ul>
<li><strong>标准方式：MPI环境提供的默认缓冲区</strong></li>
<li><strong>Bsend：MPI环境提供的buffer放到用户空间</strong></li>
<li><strong>Rsend：不要缓冲区，发送端不能提前等待</strong></li>
<li><strong>Ssend：不要缓冲区，允许等待</strong></li>
<li><strong>异步模式可以理解为MPI环境另起一个线程在后台做实际的消息传输，并通过MPI_waitxxx、MPI_Testxxx</strong> <strong>等机制与MPI进行的主线程进行通讯和同步</strong></li>
</ul>
<h5 id="阻塞与非阻塞"><a class="markdownIt-Anchor" href="#阻塞与非阻塞"></a> <strong>阻塞与非阻塞</strong></h5>
<ul>
<li><strong>阻塞操作</strong>
<ul>
<li><strong>发送操作，返回意味着发送缓冲区可以再次使用，不影响接收端结果，不表示接收端完成接收</strong></li>
<li><strong>发送可以同步方式，发送和接收间需要握手协议</strong></li>
<li><strong>发送可以异步方式，需要系统缓冲区进行消息缓存</strong></li>
<li><strong>阻塞的接收操作仅当消息接收完成后才返回</strong></li>
</ul>
</li>
<li><strong>非阻塞操作</strong>
<ul>
<li><strong>发送操作和接收操作行为类似，调用后都立即返回</strong></li>
<li><strong>在MPI环境中，在可能的时候启动通信，用户无法预测何时启动</strong></li>
<li><strong>通过某种手段确定MPI环境执行通信之前，修改发送缓冲区中的数据都是不安全的</strong></li>
<li><strong>非阻塞通信的主要目的之一是把计算和通信重叠起来，提高效率</strong></li>
</ul>
</li>
</ul>
<h5 id="操作的执行顺序及公平性"><a class="markdownIt-Anchor" href="#操作的执行顺序及公平性"></a> <strong>操作的执行顺序及“公平性”</strong></h5>
<ul>
<li>
<p><strong>顺序规定</strong></p>
<ul>
<li><strong>MPI环境保证了消息传递的顺序，及先后发送的消息在接收端不会发生顺序颠倒</strong></li>
<li><strong>如果发送进程向同一个目标进程先后发送了m1和m2两个消息，即时他们都被同一接收函数匹配，接收进程只能先接m1，再接收m2</strong></li>
<li><strong>如果接收进程先后启动两个接收动作r1和r2，都尝试接收同一消息，则r1必定在r2之前接收消息</strong></li>
<li><strong>使用了多线程的MPI环境而言，上述顺序规定不一定成立</strong></li>
</ul>
</li>
<li>
<p><strong>公平性</strong></p>
<ul>
<li><strong>MPI环境不保证“公平性”的措施，用户自己必须在程序设计中解决“操作饥饿”问题，如进程0和进程1同时向进程2发送消息，并与其中的同一个接收操作相匹配，则只有一个进程的发送动作能够完成</strong></li>
</ul>
</li>
</ul>
<h3 id="mpi集合通信"><a class="markdownIt-Anchor" href="#mpi集合通信"></a> <strong>MPI集合通信</strong></h3>
<h4 id="广播消息"><a class="markdownIt-Anchor" href="#广播消息"></a> 广播消息</h4>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “mpi.h”</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Bcast</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *buffer, <span class="comment">/*发送/接收缓冲区*/</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> count, <span class="comment">/*广播或者接收的元素个数*/</span></span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Datatype type, <span class="comment">/*广播/接收数据的数据类型*/</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> root, <span class="comment">/*广播数据的根进程的ID*/</span></span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Comm comm <span class="comment">/*通信域*/</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>
<p><strong>从root进程广播消息至所有其它的进程（同一个通信域内）</strong></p>
</li>
<li>
<p>广播注意事项:</p>
<ul>
<li>
<p><strong>通信域内的所有进程必须调用MPI_Bcast</strong></p>
</li>
<li>
<p><strong>所有的进程收到消息之后，MPI_Bcast才返回</strong></p>
</li>
<li>
<p><strong>不管是广播消息的根进程，还是从根接收消息的其它进程在调用形式上完全一致，即指明相同的根、相同的元素个数、以及相同的数据类型</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106162647977.png"
                      alt="image-20231106162647977" 
                ></p>
</li>
</ul>
</li>
</ul>
<h4 id="同步栅栏"><a class="markdownIt-Anchor" href="#同步栅栏"></a> 同步(栅栏)</h4>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “mpi.h”</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Barrier</span><span class="params">(MPI_Comm comm)</span></span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>当每个进程都到达MPI_Barrier调用后，程序才接着往下执行</strong></li>
</ul>
<h3 id="非数值并行算法mpi实现"><a class="markdownIt-Anchor" href="#非数值并行算法mpi实现"></a> <strong>非数值并行算法MPI实现</strong></h3>
<ul>
<li><strong>非数值算法</strong> <strong>基于比较关系的运算，包括排序、串匹配、图论、组合优化和计算几何等。</strong></li>
</ul>
<h4 id="并行正则采样排序psra"><a class="markdownIt-Anchor" href="#并行正则采样排序psra"></a> <strong>并行正则采样排序（PSRA）</strong></h4>
<ul>
<li>Parallel Sorting by Regular Sampling</li>
<li>基于<strong>均匀划分（Uniform Partition）原理</strong>的负载均衡的并行排序算法</li>
<li>假定待排序的元素有<strong>n个</strong>，系统中有<strong>p个</strong>处理器
<ul>
<li>首先将n个元素均匀地分割为p段，每段含有<strong>n/p</strong>个元素</li>
<li>每段指派一个处理器进行局部排序</li>
<li>从各段中抽取<strong>几个代表元素</strong>（为了使各段中诸局部有序的元素在整个序列中也能占据正确的位置）</li>
<li>再从几个代表元素中产生<strong>p-1</strong>个主元</li>
<li>然后，按这些主元与原局部有序元素之间的<strong>偏序关系</strong>，将各个局部有序段划分为<strong>p段</strong></li>
<li>接着，通过全局交换将各个段中的对应部分集合在一起，采用<strong>多路归并的方法进行排序</strong></li>
<li>最后，合并起来形成全局有序序列</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231106162940456.png"
                      alt="image-20231106162940456" 
                ></p>
<h4 id="串匹配"><a class="markdownIt-Anchor" href="#串匹配"></a> 串匹配</h4>
<blockquote>
<p><strong>串匹配问题实际上就是一种模式匹配问题，即在给定的文本串中找出与模式串匹配的子串的起始位置。</strong></p>
</blockquote>
<ul>
<li><strong>KMP串匹配的并行算法思想</strong>
<ul>
<li>首先将长度为n的文本串<strong>S均匀划分成互不重叠的p段</strong>，分布于处理器<strong>0~p-1</strong>中，且使得<strong>相邻的文本段</strong>分布在<strong>相邻的处理器</strong>中，每个处理器中局部文本段的长度为<strong>n/p</strong>(最后一个处理器可以在其段尾补上特殊字符，使其长度与其他处理器相同)</li>
<li>其次，将长为m的模式串T和模式串的next[n]函数<strong>广播</strong>到各处理器中。</li>
<li>每一个局部段i（第p-1段除外），段尾m-1字符中的匹配位置必须跨段才能找到。每个处理器（p-1除外），将本段尾<strong>m-1个字符</strong>传送给下一个<strong>处理器i+1</strong>，i+1处理器结合本段首的m-1个字符构成<strong>2*（m-1）的段间字符串</strong>，进行匹配</li>
</ul>
</li>
</ul>
<h4 id="单源最短路径问题"><a class="markdownIt-Anchor" href="#单源最短路径问题"></a> <strong>单源最短路径问题</strong></h4>
<p>输入：<strong>边权邻接矩阵W</strong>（约定顶点i，j之间无边连接时）w(i,j)=∞ ,且w(i,i)=0,待计算顶点的标号<strong>s</strong>输出：dist(0:N-1),其中**dist(i)**表示顶点s到顶点i的最短路径(1≤i≤N)</p>
<p>主要函数：</p>
<ul>
<li><strong>Main():</strong> 初始化MPI环境；调用读入矩阵函数，传输顶点个数和待计算节点标号到各从线程；给其它的从进程均匀分配顶点数。调用init()、FindMinWay()等函数</li>
<li><strong>Init():</strong> 各处理器数据初始化，proc 0向各处理器发送各处理器处理顶点数据，各处理器接收数据</li>
<li><strong>FindMinWay():</strong> 执行并行Dijsktra’s算法计算最短路径长度</li>
</ul>
<h2 id="并行算法设计与并行模式"><a class="markdownIt-Anchor" href="#并行算法设计与并行模式"></a> 并行算法设计与并行模式</h2>
<h3 id="并行算法设计基本方法"><a class="markdownIt-Anchor" href="#并行算法设计基本方法"></a> <strong>并行算法设计基本方法</strong></h3>
<h4 id="pcam设计方法学"><a class="markdownIt-Anchor" href="#pcam设计方法学"></a> PCAM设计方法学</h4>
<ul>
<li>设计并行算法的四个阶段
<ul>
<li>任务划分(Partitioning)</li>
<li>通讯分析(Communication)</li>
<li>任务组合(Agglomeration)</li>
<li>处理器映射(Mapping)</li>
</ul>
</li>
<li>划分：分解成小的任务，开拓并发性；</li>
<li>通讯：确定诸任务间的数据交换，监测划分的合理性；</li>
<li>组合：依据任务的局部性，组合成更大的任务；</li>
<li>映射：将每个任务分配到处理器上，提高算法的性能。</li>
</ul>
<h4 id="划分"><a class="markdownIt-Anchor" href="#划分"></a> <strong>划分</strong></h4>
<ul>
<li>
<p><strong>定义:</strong> 先进行数据分解(称域分解)，再进行计算功能的分解(称功能分解)；使数据集和计算集互不相交。划分阶段忽略处理器数目和目标机器的体系结构。</p>
</li>
<li>
<p><strong>数据分解</strong>: 数据并行。将数据分成很多块，每个计算任务处理一部分数据。</p>
</li>
<li>
<p><strong>功能分解</strong>: 任务并行。将计算根据功能划分，每个任务处理整个工作的一部分。</p>
</li>
</ul>
<h4 id="数值并行算法mpi实现"><a class="markdownIt-Anchor" href="#数值并行算法mpi实现"></a> <strong>数值并行算法MPI实现</strong></h4>
<ul>
<li><strong>数值算法</strong>: 基于代数关系的运算，包括矩阵运算、线性方程组的直接求解、迭代解法、矩阵特征值计算、FFT和DWT等。</li>
</ul>
<h5 id="mpi与pthread混合编程"><a class="markdownIt-Anchor" href="#mpi与pthread混合编程"></a> <strong>MPI与Pthread混合编程</strong></h5>
<blockquote>
<p>如何发挥多核的性能?</p>
<ul>
<li><strong>每一个计算节点只启动一个MPI进程；</strong></li>
<li><strong>MPI进程内启动多个线程，其中一个线程处理通信。</strong></li>
</ul>
</blockquote>
<ul>
<li><strong>主-从并行模式</strong>: 一个进程作为主进程负责分派任务，从进程执行任务
<ul>
<li><strong>0号进程（主进程）将矩阵B广播给所有MPI进程（从进程）</strong></li>
<li><strong>主进程将矩阵A的各行依次发送给从进程</strong></li>
<li><strong>从进程内启动多个线程</strong></li>
<li><strong>每一个线程分配B矩阵中的一列，与A中的一行相乘</strong></li>
<li><strong>计算结果发给主进程汇总</strong></li>
<li><strong>主进程搜集完所有的结果，结束</strong></li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231110104343554.png"
                      alt="image-20231110104343554" 
                ></p>
<ul>
<li><strong>混合编程优点</strong>
<ul>
<li><strong>每一个节点只需要一个线程参与通信，其它线程共享数据，具备较高的性能，例如广播</strong></li>
<li><strong>较快的上下文切换</strong></li>
</ul>
</li>
<li><strong>混合编程缺点</strong>
<ul>
<li><strong>编程难度大</strong></li>
<li>多个线程同时调用MPI函数(注意看使用的MPI版本是否支持<strong>MPI_THREAD_MULTIPLE</strong>)，可能崩溃</li>
</ul>
</li>
</ul>
<h4 id="通讯"><a class="markdownIt-Anchor" href="#通讯"></a> <strong>通讯</strong></h4>
<ul>
<li>
<p><strong>定义:</strong> 划分产生的诸任务，一般不能完全独立执行，需要在任务间进行数据交流；从而产生了通讯；功能分解确定了诸任务之间的数据流；诸任务是并发执行的，通讯则限制了这种并发性。</p>
</li>
<li>
<p>局部通讯:通讯限制在一个邻域内。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231110104825177.png"
                      alt="image-20231110104825177" 
                ></p>
</li>
<li>
<p>全局通讯:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231110104842598.png"
                      alt="image-20231110104842598" 
                ></p>
</li>
<li>
<p>结构化通讯:每个任务的通讯模式是相同的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231110104912816.png"
                      alt="image-20231110104912816" 
                ></p>
</li>
<li>
<p>非结构化通讯:没有一个统一的通讯模式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231110104937249.png"
                      alt="image-20231110104937249" 
                ></p>
</li>
</ul>
<h4 id="组合"><a class="markdownIt-Anchor" href="#组合"></a> <strong>组合</strong></h4>
<ul>
<li>
<p><strong>定义</strong>: 组合是由抽象到具体的过程，是将组合的任务能在一类并行机上有效的执行；合并小尺寸任务，减少任务数。如果任务数恰好等于处理器数，则也完成了映射过程；通过增加任务的粒度和重复计算，可以减少通讯成本；保持映射和扩展的灵活性，降低软件工程成本。</p>
</li>
<li>
<p>增加粒度:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231110105033487.png"
                      alt="image-20231110105033487" 
                ></p>
</li>
<li>
<p>重复计算:</p>
<ul>
<li>重复计算减少通讯量，但增加了计算量，应保持恰当的平衡</li>
<li>重复计算的目标应减少算法的总运算时间</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231110105105492.png"
                      alt="image-20231110105105492" 
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231110105117591.png"
                      alt="image-20231110105117591" 
                ></p>
</li>
</ul>
<h4 id="映射"><a class="markdownIt-Anchor" href="#映射"></a> 映射</h4>
<ul>
<li>
<p><strong>定义</strong>: 每个任务要映射到具体的处理器，定位到运行机器上；任务数大于处理器数时，存在负载平衡和任务调度问题；映射的目标是为了减少算法的执行时间；映射实际是一种权衡，属于NP完全问题。</p>
</li>
<li>
<p>映射方法：</p>
<ul>
<li>
<p>任务和处理器拥有同样的顺序编号</p>
<ul>
<li>块映射（block mapping）</li>
<li>循环映射（cyclic mapping）</li>
<li>反射映射（reflection mapping）</li>
<li>块循环映射（block-cyclic mapping）</li>
<li>块反射映射（block-reflection mapping）</li>
</ul>
</li>
<li>
<p>对于高维网格，这种映射方式可以应用于每一个维度</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231110105256214.png"
                      alt="image-20231110105256214" 
                ></p>
</li>
<li>
<p>负载平衡算法:</p>
<ul>
<li>静态的：事先确定</li>
<li>概率的：随机确定</li>
<li>动态的：执行期间动态负载</li>
</ul>
</li>
<li>
<p>基于域分解:</p>
<ul>
<li>试图将划分阶段产生的细粒度任务组合成每一个处理器上的一个粗粒度的任务
<ul>
<li>递归对剖:将一个域划分为计算成本大致相等的子域，同时试图使通信代价最小</li>
<li>局部算法:使用邻近处理器的负载信息，周期性的调整自己的负载，或转移到邻居，或从邻居迁入</li>
<li>概率方法:将任务随机的分配给处理器</li>
<li>循环映射:轮流将各种处理器分配给诸计算任务</li>
</ul>
</li>
</ul>
</li>
<li>
<p>任务调度算法:</p>
<ul>
<li>
<p>任务放在集中的或分散的任务池中，使用任务调度算法将池中的任务分配给特定的处理器。</p>
</li>
<li>
<p>常用调度模式:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231110105508978.png"
                      alt="image-20231110105508978" 
                ></p>
</li>
</ul>
</li>
</ul>
<h3 id="常用的并行模式"><a class="markdownIt-Anchor" href="#常用的并行模式"></a> <strong>常用的并行模式</strong></h3>
<h4 id="流水线并行"><a class="markdownIt-Anchor" href="#流水线并行"></a> 流水线并行</h4>
<p>定义：流水线是生产者-消费链。数据流通过一串计算任务，前一计算任务的输出是下一个计算任务的输入。</p>
<p>分类：</p>
<ul>
<li>线性流水线</li>
<li>非线性流水线</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231117231240011.png"
                      alt="image-20231117231240011" 
                ></p>
<h4 id="主从并行模式"><a class="markdownIt-Anchor" href="#主从并行模式"></a> 主从并行模式</h4>
<p>定义：一个进程（线程）作为master,其它进程(线程)作为worker:</p>
<ul>
<li><strong>master产生和管理任务；</strong></li>
<li><strong>master调度并分派任务给worker；</strong></li>
<li><strong>worker完成分派的任务之后，向master请求更多的任务</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231117231506216.png"
                      alt="image-20231117231506216" 
                ></p>
<h4 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h4>
<p>定义：创建一定数量线程，配备一个任务队列，存放其它线程提交的任务。线程池内的线程从队列中取任务执行，如果队列中没任务，线程池内的线程挂起。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231117231515809.png"
                      alt="image-20231117231515809" 
                ></p>
<p><strong>使用线程池的优势</strong>：</p>
<ul>
<li>消除频繁创建撤销线程的开销</li>
<li>较快的响应速度</li>
<li>避免过量占用系统资源（相比每到达一个任务就创建一个线程的方式）</li>
</ul>
<h4 id="分而治之模式"><a class="markdownIt-Anchor" href="#分而治之模式"></a> 分而治之模式</h4>
<p>定义：<strong>将问题被分成许多并行的子问题，最后合并结果。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231117231615962.png"
                      alt="image-20231117231615962" 
                ></p>
<h2 id="并行计算性能分析"><a class="markdownIt-Anchor" href="#并行计算性能分析"></a> 并行计算性能分析</h2>
<h3 id="并行程序性能度量"><a class="markdownIt-Anchor" href="#并行程序性能度量"></a> <strong>并行程序性能度量</strong></h3>
<p><strong>并行运行时间(parallel runtime)</strong> ：是指从第一个处理器（线程）开始执行程序到最后一个处理器（线程）完成运算所花费的时间。</p>
<p><strong>加速比(speedup)</strong> ：顺序执行程序执行时间除以计算同一问题的并行程序的执行时间。即： 加速比$S§=T_1/T_p$ $T_1$是顺序执行时间，$T_p$是运行在P个处理器上并行时间</p>
<p><strong>效率 (efficieny）</strong> ：是处理器被有效利用情况的度量。它定义为加速比与处理器数目的比率，即：$E§=S§/P$ S是加速比，P是处理器数目</p>
<blockquote>
<ul>
<li><strong>理性情况下：加速比等于P，效率等于1</strong></li>
<li><strong>实际情况：效率在0和1之间</strong></li>
<li><strong>极其稀有情况：效率大于1</strong></li>
</ul>
</blockquote>
<h3 id="影响并行程序性能的因素"><a class="markdownIt-Anchor" href="#影响并行程序性能的因素"></a> <strong>影响并行程序性能的因素</strong></h3>
<h4 id="开销"><a class="markdownIt-Anchor" href="#开销"></a> <strong>开销</strong></h4>
<p><strong>并行程序需要付出的开销</strong></p>
<ul>
<li><strong>线程(进程)创建</strong> :尽量避免在计算过程中频繁创建和撤销线程(进程)</li>
<li><strong>通信</strong> :处理器间的通信（假共享时）、共享内存的进程间通信（内存拷贝）、分布式内存的进程间通信（网络传输+内存拷贝）</li>
<li><strong>同步开销</strong> :同步开销存在于：一个线程等待另外一个线程出现某一事件，例如，等待其它线程释放锁</li>
<li><strong>冗余计算</strong> :进行任务分配需要的计算、并行任务间的重复计算</li>
</ul>
<h4 id="不可并行的代码"><a class="markdownIt-Anchor" href="#不可并行的代码"></a> <strong>不可并行的代码</strong></h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://charles2530.github.io/image/parallel-programming-theory/image-20231124215425399.png"
                      alt="image-20231124215425399" 
                ></p>
<p><strong>Amdahl’s Law和加速比的关系</strong></p>
<ul>
<li>根据Amdahl’s Law很难获得好的加速比</li>
<li>$T_{seq}$ :串行执行时间</li>
<li>$T_{par}$ :并行执行时间</li>
<li>$T_p=T_{seq}+T_{par},T_1=T_{seq}+pT_{par}$</li>
<li>$f_{par}$ 是可以并行的部分$T_{par}/T_p$</li>
<li>$Scaled\ speedup=S_p=1+(p-1)T_{par}/T_p=1+(p-1)f_{par}$</li>
</ul>
<h4 id="竞争-2"><a class="markdownIt-Anchor" href="#竞争-2"></a> <strong>竞争</strong></h4>
<p><strong>为争夺共享资源而引起的竞争将使系统性能衰减</strong></p>
<ul>
<li><strong>竞争锁</strong> :自旋锁和互斥锁，其中自旋锁尤其耗资源</li>
<li><strong>I/O带宽</strong> :内存I/O、磁盘I/O、网络I/O</li>
</ul>
<h4 id="处理器闲置"><a class="markdownIt-Anchor" href="#处理器闲置"></a> <strong>处理器闲置</strong></h4>
<p><strong>高性能并行程序的追求：</strong> 处理器要得到充分利用，即，所有处理器任意时刻都忙于计算</p>
<p><strong>引起处理器闲置的原因</strong>:</p>
<ul>
<li><strong>负载不均衡</strong> :任务分配不均匀、计算能力不均衡（相同的硬件配置不代表相同的计算能力）</li>
<li><strong>等待数据</strong> :等待来自网络、磁盘或者存储器的数据</li>
</ul>
<h3 id="并行程序的可扩展性"><a class="markdownIt-Anchor" href="#并行程序的可扩展性"></a> <strong>并行程序的可扩展性</strong></h3>
<p><strong>可扩展性(Scalability)</strong> :如果处理器从P-1增加到P，加速比仍旧在提高，那么称该并行程序能够扩展到P个处理器</p>
<p>影响扩展性的因素：</p>
<ul>
<li><strong>I/O</strong>:网络、内存带宽、磁盘</li>
<li><strong>并行算法</strong></li>
<li><strong>并行开销</strong></li>
<li><strong>编码实现</strong></li>
</ul>
<h3 id="改进并行程序性能的几种策略"><a class="markdownIt-Anchor" href="#改进并行程序性能的几种策略"></a> <strong>改进并行程序性能的几种策略</strong></h3>
<h4 id="数据相关性依赖性"><a class="markdownIt-Anchor" href="#数据相关性依赖性"></a> 数据相关性（依赖性）</h4>
<p><strong>数据相关性 (Data Dependencies)</strong> :是指对存储器操作的顺序，为了保证正确性必须保持这种排序关系。</p>
<blockquote>
<p>如果两个计算没有依赖性，即，执行顺序不影响程序正确性，则这两个计算能够并行</p>
</blockquote>
<h4 id="并行粒度"><a class="markdownIt-Anchor" href="#并行粒度"></a> 并行粒度</h4>
<p><strong>并行粒度 (Parallel Granularity )</strong> :由线程或者进程间的交互频率决定，是计算与通信频率比例的定性度量。</p>
<ul>
<li><strong>粗粒度并行</strong> ：线程或者进程两次通信之间，进行相对大量的计算工作。</li>
<li><strong>细粒度并行</strong> ：指的是线程或者进程间交互频繁的计算。</li>
</ul>
<h5 id="有关并行粒度的探讨"><a class="markdownIt-Anchor" href="#有关并行粒度的探讨"></a> <strong>有关并行粒度的探讨</strong></h5>
<p><strong>应用：</strong></p>
<ul>
<li><strong>如果通信延迟大，适合粗粒度并行，例如消息传递、进程间通信</strong></li>
<li><strong>如果通信延迟小，可以采用细粒度并行，例如GPU的数据并行、多线程</strong></li>
</ul>
<p><strong>经验：</strong></p>
<ul>
<li><strong>不要用固定的并行粒度，应该使计算的粒度与可用的计算资源以及求解问题具体需求相匹配</strong></li>
<li><strong>粗粒度并行会降低同步开销，提高性能，但可能引起:</strong>
<ul>
<li><strong>计算的不均衡(处理器闲置)</strong></li>
<li><strong>影响可扩展性(降低并发度）</strong></li>
</ul>
</li>
</ul>
<h4 id="局部性"><a class="markdownIt-Anchor" href="#局部性"></a> 局部性</h4>
<p><strong>局部性(Locality）</strong>：主要分为“时间局部性”和“空间局部性”，是提升程序性能的一个重要因素</p>
<ul>
<li><strong>空间局部性(Spatial locality):加载一个地址的数据之后，继续加载它附近的数据</strong></li>
<li><strong>时间局部性(Temporal locality)：在加载一个地址的数据之后，短时间内重新加载这块数据</strong></li>
</ul>
<h4 id="重叠通信和计算"><a class="markdownIt-Anchor" href="#重叠通信和计算"></a> 重叠通信和计算</h4>
<p>通过并发执行计算和通信，通信的延迟就可部分或者完全被隐藏</p>
<h4 id="任务动态分配"><a class="markdownIt-Anchor" href="#任务动态分配"></a> 任务动态分配</h4>
<p>即使同样的计算任务，在同样的硬件配置上运行，执行时间也会产生差异，长时间运行情况会更加恶化：</p>
<ul>
<li><strong>慢节点</strong></li>
<li><strong>其它作业干扰</strong></li>
</ul>
<h3 id="并行程序性能分析工具"><a class="markdownIt-Anchor" href="#并行程序性能分析工具"></a> <strong>并行程序性能分析工具</strong></h3>
<p><strong>并行程序分析及其复杂性</strong></p>
<ul>
<li>
<p>更好的利用高性能计算机器</p>
<ul>
<li>必须会写高性能并行程序</li>
<li>需要综合了解和优化编程模型、算法、语言和平台等</li>
</ul>
</li>
<li>
<p>并行性能测量、分析和优化是一个复杂的过程</p>
</li>
<li>
<p>并行性能研究是研究重点</p>
</li>
</ul>
<p><strong>性能测量的基准</strong></p>
<ul>
<li>测量基准：通常包括对一类程序评估的测量度量
<ul>
<li>一种实验方法的标准</li>
<li>一种基准程序收集的标准</li>
<li>一组量纲的标准</li>
</ul>
</li>
</ul>
<p><strong>并行程序性能分析动机</strong></p>
<ul>
<li>并行、分布式系统是复杂的
<ul>
<li>四个层次
<ul>
<li>应用层（application）
<ul>
<li>算法和数据结构</li>
</ul>
</li>
<li>并行编程接口/中间件应用层（Interface/Middleware）
<ul>
<li>编译器、并行库、通讯、同步</li>
</ul>
</li>
<li>操作系统（Operating system）
<ul>
<li>进程、线程、内存、IO管理</li>
</ul>
</li>
<li>硬件（Hardware）
<ul>
<li>CPU、内存、网络等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>不同层之间的映射和互操作</li>
</ul>
<p><strong>性能因素</strong></p>
<ul>
<li>
<p>确定一个程序的性能因素是复杂的，相互关联的，甚至是隐含的。</p>
</li>
<li>
<p>应用相关的因素</p>
<ul>
<li>算法数据集大小、任务粒度、内存使用模式、负载均衡、I/O通讯模式等</li>
</ul>
</li>
<li>
<p>硬件相关的因素</p>
<ul>
<li>处理器体系结构、分级存储体系结构、I/O通讯网络等</li>
</ul>
</li>
<li>
<p>软件相关的因素</p>
<ul>
<li>操作系统、编译器/预处理器、通讯协议、函数库等</li>
</ul>
</li>
</ul>
<p><strong>计算资源的使用</strong></p>
<ul>
<li>资源通常低效使用或无效使用
<ul>
<li>识别出这些情况可知存在性能问题</li>
</ul>
</li>
<li>资源通常是“Virtual”
<ul>
<li>不是真实的物理资源（如线程、进程等）</li>
</ul>
</li>
<li>性能分析工具
<ul>
<li>帮助程序员了解程序是如何真正运行的</li>
<li>提供建议如何进行性能调优</li>
</ul>
</li>
</ul>
<p><strong>性能分析和调优：基础</strong></p>
<ul>
<li>
<p>性能调优的目标是减少程序的执行时间</p>
<ul>
<li>迭代以优化效率</li>
<li>效率和执行时间是相关的</li>
</ul>
</li>
<li>
<p>程序的热点并消除性能瓶颈</p>
<ul>
<li>
<p>热点：程序中的一段代码，不成比例的使用高处理器时间</p>
</li>
<li>
<p>性能瓶颈：程序中的一段代码，无效的使用处理器资源，因此产生不必要的延迟</p>
</li>
</ul>
</li>
</ul>
<p><strong>串行性能（Sequential Performance）</strong></p>
<ul>
<li>
<p>串行性能</p>
<ul>
<li>
<p>时间是如何分布的</p>
</li>
<li>
<p>何时和何地使用了什么资源</p>
</li>
</ul>
</li>
<li>
<p>串行因素</p>
<ul>
<li>
<p>计算</p>
<ul>
<li>
<p>选择正确的算法是最重要的</p>
</li>
<li>
<p>编译器支持</p>
</li>
</ul>
</li>
<li>
<p>存储系统（缓存和内存）</p>
<ul>
<li>
<p>很难评定和决定效果</p>
</li>
<li>
<p>模型支持</p>
</li>
</ul>
</li>
<li>
<p>输入/输出</p>
</li>
</ul>
</li>
<li>
<p>并行性能</p>
<ul>
<li>
<p>串行性能+并行交互</p>
<ul>
<li>
<p>串行性能是每一个进程/线程的执行时间</p>
</li>
<li>
<p>并行交互是进程/线程之间的通讯时间</p>
</li>
</ul>
</li>
<li>
<p>“并行”导致额外开销</p>
<ul>
<li>
<p>并发（进程/线程）</p>
</li>
<li>
<p>进程间通讯（消息传递）</p>
</li>
<li>
<p>同步（显式/隐式）</p>
</li>
</ul>
</li>
<li>
<p>并行之间的互操作也会导致并行无效</p>
<ul>
<li>负载不均衡</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>串行性能调优（Tuning）</strong></p>
<ul>
<li>
<p>串行性能调优是一个时间驱动（time-driven ）过程</p>
</li>
<li>
<p>寻找花费最多时间的代码，使其花费少量的时间</p>
</li>
<li>
<p>通常进行程序重组</p>
<ul>
<li>
<p>数据存储和组织结构的变化</p>
</li>
<li>
<p>重排任务或操作过程</p>
</li>
</ul>
</li>
<li>
<p>更好利用资源的方法</p>
<ul>
<li>
<p>缓存管理</p>
</li>
<li>
<p>本地化</p>
</li>
<li>
<p>虚拟内存管理</p>
</li>
</ul>
</li>
<li>
<p>更好的处理器使用方法</p>
</li>
</ul>
<p><strong>并行性能调优（Tuning）</strong></p>
<ul>
<li>
<p>并行性能调优是冲突驱动（conflict-driven or interaction-driven）</p>
</li>
<li>
<p>寻找并行互操作点，分析其开销</p>
</li>
<li>
<p>开销包括互操作的花费</p>
<ul>
<li>
<p>数据传输</p>
</li>
<li>
<p>协调过程中的额外操作</p>
</li>
</ul>
</li>
<li>
<p>开销也包括等待时间</p>
</li>
</ul>
<p><strong>执行时间（Execution Time）</strong></p>
<ul>
<li>
<p>不同类型的时间</p>
</li>
<li>
<p><strong>Wall-clock time</strong></p>
<ul>
<li>
<p>基于实际时钟 (不间断运行)</p>
</li>
<li>
<p>包括花费在所有活动上的时间</p>
</li>
</ul>
</li>
<li>
<p>Virtual process time虚过程时间 (aka CPU time)</p>
<ul>
<li>
<p>进程执行时间 (CPU运行)</p>
<ul>
<li>用户时间和系统时间</li>
</ul>
</li>
<li>
<p>不包括进程内在等待的时间</p>
</li>
</ul>
</li>
<li>
<p>并行执行时间</p>
<ul>
<li>
<p>任何并行部分执行过程中的时间</p>
</li>
<li>
<p>需要定义一个全局时间基准</p>
</li>
</ul>
</li>
</ul>
<p><strong>Observation类型</strong></p>
<ul>
<li>
<p>根据不同的测量方法</p>
<ul>
<li>
<p>直接性能观察</p>
</li>
<li>
<p>间接性能观察</p>
</li>
</ul>
</li>
<li>
<p>直接性能观察基于测量的科学理论，考虑到开销的精确性</p>
</li>
<li>
<p>间接性能观察基于测量的采样理论，假设一定程度上的统计稳定性</p>
</li>
</ul>
<p><strong>直接性能观察</strong></p>
<ul>
<li>
<p>执行行为描述为事件</p>
<ul>
<li>
<p>行为反映为一些执行状态</p>
</li>
<li>
<p>事件编码</p>
</li>
</ul>
</li>
<li>
<p>观察是直接的</p>
<ul>
<li>
<p>直接在代码中插桩 (探针)</p>
</li>
<li>
<p>插桩代码调用性能测量程序</p>
</li>
<li>
<p>事件测量 = 性能数据 + 上下文</p>
</li>
</ul>
</li>
<li>
<p>性能实验</p>
<ul>
<li>实际事件 + 性能测量</li>
</ul>
</li>
</ul>
<h3 id="并行性能分析的未来"><a class="markdownIt-Anchor" href="#并行性能分析的未来"></a> <strong>并行性能分析的未来</strong></h3>
<ul>
<li>
<p><strong>性能是高性能计算的最基本驱动力</strong></p>
<ul>
<li><strong>Performance的观察，建模和工程学设计是开发并行潜能和高性能计算机的关键方法论</strong></li>
</ul>
</li>
<li>
<p><strong>在并行程序分析工具和并行计算之间的关系</strong></p>
<ul>
<li><strong>关注性能是必要的，但是是事后的</strong></li>
</ul>
</li>
<li>
<p><strong>需要研究在并行计算的整个过程中强制推行性能分析的方法和技术</strong></p>
<ul>
<li>
<p><strong>获得、学习和推进性能知识</strong></p>
</li>
<li>
<p><strong>处理扩展性和复杂性问题</strong></p>
</li>
<li>
<p><strong>在程序的语义（计算模型）和具体执行模型上考虑性能分析的功能</strong></p>
</li>
</ul>
</li>
</ul>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> parallel_programming_theory</li>
        <li><strong>Author:</strong> Charles</li>
        <li><strong>Created at
                :</strong> 2023-11-06 12:47:19</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2023-11-24 22:41:53
            </li>
        
        <li>
            <strong>Link:</strong> https://charles2530.github.io/2023/11/06/parallel-programming-theory/
        </li>
        <li>
            <strong>
                License:
            </strong>
            
            This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>.
            

        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/other/">#other</a>&nbsp;
                    </li>
                
            </ul>
        

        
  <div class="recommended-article">
   <div class="recommended-desktop">
    <div class="recommended-article-header">
     <i aria-hidden="true"></i><span>recommend_articles</span>
    </div>
    <div class="recommended-article-group"><a class="recommended-article-item" href="/2022/12/30/os-theory-1/" title="OS_theory_1" rel="bookmark">
  <img src="https://charles2530.github.io/image/background/p5.jfif" alt="OS_theory_1" class="!max-w-none">
  <span class="title">OS_theory_1</span>
</a><a class="recommended-article-item" href="/2023/09/29/swiftui-basis/" title="SwiftUI-basis" rel="bookmark">
  <img src="https://charles2530.github.io/image/background/p3.png" alt="SwiftUI-basis" class="!max-w-none">
  <span class="title">SwiftUI-basis</span>
</a><a class="recommended-article-item" href="/2023/09/05/decision-tree/" title="decision-tree" rel="bookmark">
  <img src="https://charles2530.github.io/image/background/p3.png" alt="decision-tree" class="!max-w-none">
  <span class="title">decision-tree</span>
</a></div>
   </div>
   <div class="recommended-mobile">
   <div class="recommended-article-header">
     <i aria-hidden="true"></i><span>recommend_articles</span>
   </div>
   <div class="recommended-article-group"><a class="recommended-article-item" href="/2022/12/30/os-theory-1/" title="OS_theory_1" rel="bookmark">
  <img src="https://charles2530.github.io/image/background/p5.jfif" alt="OS_theory_1" class="!max-w-none">
  <span class="title">OS_theory_1</span>
</a><a class="recommended-article-item" href="/2023/09/29/swiftui-basis/" title="SwiftUI-basis" rel="bookmark">
  <img src="https://charles2530.github.io/image/background/p3.png" alt="SwiftUI-basis" class="!max-w-none">
  <span class="title">SwiftUI-basis</span>
</a></div>
   </div>
  </div>

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                        rel="prev"
                        href="/2023/12/08/algorithm-buaa-note/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">algorithm-buaa-note</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                        rel="next"
                        href="/2023/11/05/optimisation-theory/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">optimisation theory</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
            <div class="comment-container">
                <div class="comments-container pjax">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fa-solid fa-comments"></i>&nbsp;Comments
    </div>
    

        <!-- 
            
    <div id="gitalk-container"></div>
    <script data-swup-reload-script
            src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
    <script data-swup-reload-script>

        function loadGitalk() {
            let __gitalk__pathname = decodeURI(location.pathname);
            const __gitalk__pathnameLength = __gitalk__pathname.length;
            const __gitalk__pathnameMaxLength = 50;
            if (__gitalk__pathnameLength > __gitalk__pathnameMaxLength) {
                __gitalk__pathname = __gitalk__pathname.substring(0, __gitalk__pathnameMaxLength - 3) + '...';
            }

            try {
                Gitalk && new Gitalk({
                    clientID: '8083299a8ee2aaf23879',
                    clientSecret: 'a8161e81d4872181e884fdb69f7be24916b6a9d0',
                    repo: 'charles2530_issues',
                    owner: 'Charles2530',
                    admin: ['Charles2530'],
                    id: __gitalk__pathname,
                    language: 'en'
                }).render('gitalk-container');

            } catch (e) {
                window.Gitalk = null;
            }
        }

        if ('true') {
            const loadGitalkTimeout = setTimeout(() => {
                loadGitalk();
                clearTimeout(loadGitalkTimeout);
            }, 1000);
        } else {
            window.addEventListener('DOMContentLoaded', loadGitalk);
        }
    </script>



         -->
        <script src="https://utteranc.es/client.js" repo="Charles2530/Charles2530.github.io" issue-term="pathname"
            label="Comment" theme="preferred-color-scheme" crossorigin="anonymous" async>
            </script>
        
</div>
            </div>
        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">parallel_programming_theory</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-text"> 并行程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80"><span class="nav-text"> 并行计算基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97"><span class="nav-text"> 传统的并行计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97"><span class="nav-text"> 并行计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91vs%E5%B9%B6%E8%A1%8C"><span class="nav-text"> 并发vs并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8Cvs%E5%88%86%E5%B8%83%E5%BC%8F"><span class="nav-text"> 并行vs分布式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text"> 并行计算的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="nav-text"> 并行的层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%86%E7%B1%BB"><span class="nav-text"> 并行计算机分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98shared-memory"><span class="nav-text"> 共享内存(Shared Memory)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%86%85%E5%AD%98distributed-memory"><span class="nav-text"> 分布式内存(Distributed Memory)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98distributed-shared-memory"><span class="nav-text"> 分布式共享内存(Distributed-Shared Memory)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-text"> 多进程程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E7%82%B9"><span class="nav-text"> 进程的概念和特点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text"> 进程相关的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="nav-text"> 进程与线程区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B"><span class="nav-text"> 进程间通信模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text"> 进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8Bid"><span class="nav-text"> 进程ID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-text"> 进程创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-text"> 进程终止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="nav-text"> 子进程回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%96%B0%E7%A8%8B%E5%BA%8F"><span class="nav-text"> 执行一个新程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7signal"><span class="nav-text"> 信号(signal)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="nav-text"> 发送信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E4%BF%A1%E5%8F%B7"><span class="nav-text"> 接收信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%97%B6%E6%8E%A5%E6%94%B6%E5%A4%9A%E4%B8%AA%E4%BF%A1%E5%8F%B7"><span class="nav-text"> 同时接收多个信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%98%BB%E5%A1%9E"><span class="nav-text"> 信号阻塞</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-text"> 进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-text"> 消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="nav-text"> 特殊情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C"><span class="nav-text"> 消息队列操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8Fnamed-semaphores"><span class="nav-text"> 信号量（named semaphores）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="nav-text"> 信号量相关操作</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-text"> 多线程程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-text"> 线程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9A%E4%B9%89"><span class="nav-text"> 线程定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8A%BF"><span class="nav-text"> 线程优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B"><span class="nav-text"> 使用线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text"> 线程的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-text"> 线程创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AF%86"><span class="nav-text"> 线程标识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="nav-text"> 线程回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-text"> 线程终止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB"><span class="nav-text"> 线程分离</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F"><span class="nav-text"> 多线程的共享变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-text"> 线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5mutex"><span class="nav-text"> 互斥(Mutex)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore"><span class="nav-text"> 信号量(semaphore)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-text"> 条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81"><span class="nav-text"> 条件变量初始化和销毁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6%E6%88%90%E7%AB%8B"><span class="nav-text"> 等待条件成立</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%94%A4%E9%86%92%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B"><span class="nav-text"> 唤醒等待线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E9%94%81%E7%BA%BF%E7%A8%8B"><span class="nav-text"> 解锁线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="nav-text"> 多线程信号处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text"> 线程信号处理函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-text"> 并发常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text"> 线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0reentrant-function"><span class="nav-text"> 可重入函数(reentrant function)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AB%9E%E4%BA%89"><span class="nav-text"> 竞争</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-text"> 死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%87%E5%85%B1%E4%BA%AB"><span class="nav-text"> 假共享</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AA%E6%95%B0%E9%99%90%E5%88%B6"><span class="nav-text"> 线程个数限制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mpi%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-text"> MPI并行程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A4%E8%AF%86mpi"><span class="nav-text"> 认识MPI</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFmpi"><span class="nav-text"> 什么是MPI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B"><span class="nav-text"> 消息通信模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mpi%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-text"> MPI编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mpi%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text"> MPI初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mpi%E7%BB%93%E6%9D%9F"><span class="nav-text"> MPI结束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8Bid"><span class="nav-text"> 当前进程ID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E5%9F%9F%E5%86%85%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%95%B0"><span class="nav-text"> 通信域内的进程数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="nav-text"> 发送消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="nav-text"> 接收消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="nav-text"> 死锁的产生</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%AF%B9%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BD%BF%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text"> 各种模式对缓冲区使用的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-text"> 阻塞与非阻塞</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%8F%8A%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="nav-text"> 操作的执行顺序及“公平性”</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mpi%E9%9B%86%E5%90%88%E9%80%9A%E4%BF%A1"><span class="nav-text"> MPI集合通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF"><span class="nav-text"> 广播消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%A0%85%E6%A0%8F"><span class="nav-text"> 同步(栅栏)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E6%95%B0%E5%80%BC%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95mpi%E5%AE%9E%E7%8E%B0"><span class="nav-text"> 非数值并行算法MPI实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E6%AD%A3%E5%88%99%E9%87%87%E6%A0%B7%E6%8E%92%E5%BA%8Fpsra"><span class="nav-text"> 并行正则采样排序（PSRA）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B2%E5%8C%B9%E9%85%8D"><span class="nav-text"> 串匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="nav-text"> 单源最短路径问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%B9%B6%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="nav-text"> 并行算法设计与并行模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="nav-text"> 并行算法设计基本方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pcam%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E5%AD%A6"><span class="nav-text"> PCAM设计方法学</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%92%E5%88%86"><span class="nav-text"> 划分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95mpi%E5%AE%9E%E7%8E%B0"><span class="nav-text"> 数值并行算法MPI实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#mpi%E4%B8%8Epthread%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B"><span class="nav-text"> MPI与Pthread混合编程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%AE%AF"><span class="nav-text"> 通讯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88"><span class="nav-text"> 组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%A0%E5%B0%84"><span class="nav-text"> 映射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="nav-text"> 常用的并行模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%B9%B6%E8%A1%8C"><span class="nav-text"> 流水线并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%B9%B6%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="nav-text"> 主从并行模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text"> 线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E6%A8%A1%E5%BC%8F"><span class="nav-text"> 分而治之模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-text"> 并行计算性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F"><span class="nav-text"> 并行程序性能度量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%B1%E5%93%8D%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="nav-text"> 影响并行程序性能的因素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E9%94%80"><span class="nav-text"> 开销</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%B9%B6%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-text"> 不可并行的代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AB%9E%E4%BA%89-2"><span class="nav-text"> 竞争</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E9%97%B2%E7%BD%AE"><span class="nav-text"> 处理器闲置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7"><span class="nav-text"> 并行程序的可扩展性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AD%96%E7%95%A5"><span class="nav-text"> 改进并行程序性能的几种策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E6%80%A7%E4%BE%9D%E8%B5%96%E6%80%A7"><span class="nav-text"> 数据相关性（依赖性）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E7%B2%92%E5%BA%A6"><span class="nav-text"> 并行粒度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E5%85%B3%E5%B9%B6%E8%A1%8C%E7%B2%92%E5%BA%A6%E7%9A%84%E6%8E%A2%E8%AE%A8"><span class="nav-text"> 有关并行粒度的探讨</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7"><span class="nav-text"> 局部性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%8F%A0%E9%80%9A%E4%BF%A1%E5%92%8C%E8%AE%A1%E7%AE%97"><span class="nav-text"> 重叠通信和计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="nav-text"> 任务动态分配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="nav-text"> 并行程序性能分析工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%9A%84%E6%9C%AA%E6%9D%A5"><span class="nav-text"> 并行性能分析的未来</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2022</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">Charles</a>
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">Visitor Count</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">Total Page Views</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">Powered by Charles</span>
            <span class="text-sm lg:block">Theme&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.5.0</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
            
                
        
                
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="right-bottom-tools rss flex justify-center items-center">
                <a class="flex justify-center items-center"
                   href="/atom.xml"
                   target="_blank"
                >
                <i class="fa-regular fa-rss"></i>
                </a>
            </li>
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>


    <script src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/libs/Swup.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/libs/SwupSlideTheme.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/libs/SwupScriptsPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/libs/SwupProgressPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/libs/SwupScrollPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/libs/SwupPreloadPlugin.min.js"></script>
<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>





 <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/tools/imageViewer.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/utils.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/main.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/layouts/navbarShrink.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/tools/scrollTopBottom.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/tools/lightDarkSwitch.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/layouts/categoryList.js"></script>


    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/tools/localSearch.js"></script>



    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/tools/codeBlock.js"></script>



    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/layouts/lazyload.js"></script>



    <script src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/tools/runtime.js"></script>
    <script src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/libs/odometer.min.js"></script>
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/assets/odometer-theme-minimal.css">



  <script src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/libs/Typed.min.js"></script>
  <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/plugins/typed.js"></script>



    <script src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/libs/mermaid.min.js"></script>
    <script src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/plugins/mermaid.js"></script>



    <script src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/libs/minimasonry.min.js"></script>
    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/plugins/masonry.js"></script>



<div class="post-scripts" data-swup-reload-script>
    
        <script src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/libs/anime.min.js"></script>
        <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/tools/tocToggle.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/layouts/toc.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.5.0/source/js/plugins/tabs.js"></script>
    
</div>
 
  </body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>
